<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端日常记录</title>
    <url>/blog/2022/07/22/record/frontendRecord/</url>
    <content><![CDATA[<h2 id="让移动端滑动更加顺畅"><a href="#让移动端滑动更加顺畅" class="headerlink" title="让移动端滑动更加顺畅"></a>让移动端滑动更加顺畅</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-webkit-<span class="attribute">overflow</span>-scrolling: touch;</span><br></pre></td></tr></table></figure>

<h2 id="react项目启动用https的命令"><a href="#react项目启动用https的命令" class="headerlink" title="react项目启动用https的命令"></a>react项目启动用https的命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(<span class="variable">$env</span>:HTTPS = <span class="string">&quot;true&quot;</span>) -and (npm start)</span><br></pre></td></tr></table></figure>

<h2 id="文本溢出-省略号"><a href="#文本溢出-省略号" class="headerlink" title="文本溢出 省略号"></a>文本溢出 省略号</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 多行溢出 */</span></span><br><span class="line"><span class="attribute">overflow</span> : hidden;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单行溢出*/</span></span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure>

<!-- [webpck HYPERLINK "https://segmentfault.com/q/1010000009360389"是不是不能编译这个属性 HYPERLINK "https://segmentfault.com/q/1010000009360389"-webkit-box-orient: vertical](https://segmentfault.com/q/1010000009360389)需要加上下面这段 -->
<blockquote>
<p>多行溢出不生效 可能情况webpack原因：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*! autoprefixer: off */</span></span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line"><span class="comment">/* autoprefixer: on */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! autoprefixer: ignore next */</span></span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure>

<p>参考文档<a href="https://segmentfault.com/q/1010000009360389">https://segmentfault.com/q/1010000009360389</a></p>
<h2 id="缩短网址http-dwz-cn"><a href="#缩短网址http-dwz-cn" class="headerlink" title="缩短网址http://dwz.cn"></a>缩短网址<a href="http://dwz.cn/">http://dwz.cn</a></h2><h2 id="IOS-问题"><a href="#IOS-问题" class="headerlink" title="IOS 问题"></a>IOS 问题</h2><blockquote>
<p>Iphone 禁止浏览器弹性滚动<br>Iphone 禁止浏览器弹性滚动  给最外层的盒子上加上 touch-action:none;<br>如果还是不行就给body加个 height：100%;</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>() <span class="comment">// 阻止默认的处理方式(阻止下拉滑动的效果)</span></span><br><span class="line">&#125;, &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;) <span class="comment">// passive 参数不能省略，用来兼容ios和android</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ios键盘弹出导致失去焦点问题</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">hanldeBlur = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> scrollHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> || <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">max</span>(scrollHeight - <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>husky lint-staged</code></p>
<p>这两个包在windows下安装必须用npm 不能用cnpm否则无效</p>
<blockquote>
<p>ios <code>active伪类失效</code> 解决方案</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ontouchstart</span>=<span class="string">&quot;&quot;</span> <span class="attr">onmouseover</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>YYYY-MM-DD 这种日期格式在转换时 ios上会出问题 建议用 YYYY/MM/DD</p>
</blockquote>
<blockquote>
<p>safari 在低版本对箭头函数的嵌套支持不好 会卡死</p>
</blockquote>
<h2 id="Chrome-浏览器目标填写"><a href="#Chrome-浏览器目标填写" class="headerlink" title="Chrome 浏览器目标填写"></a>Chrome 浏览器目标填写</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- -args --disable-web-security --enable-easy-off-store-extension-install --args --disable-web-security --user-data-dir</span><br><span class="line">- -args --disable-web-security --user-data-dir</span><br></pre></td></tr></table></figure>

<h2 id="浏览器console里自动写Cookie"><a href="#浏览器console里自动写Cookie" class="headerlink" title="浏览器console里自动写Cookie"></a>浏览器console里自动写Cookie</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;xxx你的cookie;&#x27;</span></span><br><span class="line"></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/\s*/ig</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">cookie</span> = item + <span class="string">&#x27;; domain=cekid.com; path=/&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Nginx-常用配置"><a href="#Nginx-常用配置" class="headerlink" title="Nginx 常用配置:"></a>Nginx 常用配置:</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">server</span> &#123;</span><br><span class="line">  <span class="string">listen</span>  <span class="number">80</span><span class="string">;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#   server_name</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">root</span> <span class="string">/data/web/happy-pig;</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">error_log</span> <span class="string">/root/nginx_err.log;</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="string">try_files</span> <span class="string">$uri</span> <span class="string">@fallback;</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="string">location</span> <span class="string">/happy_pig/api/</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="string">proxy_set_header</span> <span class="string">X-Real-IP</span> <span class="string">$remote_addr;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">proxy_set_header</span> <span class="string">X-Forward-For</span> <span class="string">$proxy_add_x_forwarded_for;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">proxy_set_header</span> <span class="string">Host</span> <span class="string">$http_host;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">proxy_set_header</span> <span class="string">X-Nginx-Proxy</span> <span class="literal">true</span><span class="string">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#       proxy_redirect   off;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">proxy_pass</span> [<span class="string">http://127.0.0.1:8081</span>]<span class="string">(http://127.0.0.1:8081/);</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="string">location</span> <span class="string">@fallback</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="string">rewrite</span> <span class="string">.*</span> <span class="string">/index.html</span> <span class="string">break;</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eventloop"><a href="#eventloop" class="headerlink" title="eventloop"></a>eventloop</h2><blockquote>
<p><a href="https://juejin.im/post/5c9a43175188252d876e5903">参考链接 https://juejin.im/post/5c9a43175188252d876e5903</a></p>
</blockquote>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>linxu常用命令</title>
    <url>/blog/2022/07/22/record/linuxRecord/</url>
    <content><![CDATA[<h2 id="linux-查看内存占用前十的进程"><a href="#linux-查看内存占用前十的进程" class="headerlink" title="linux 查看内存占用前十的进程"></a>linux 查看内存占用前十的进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux|<span class="built_in">head</span> -1;ps aux|grep -v PID|<span class="built_in">sort</span> -rn -k +3|<span class="built_in">head</span></span><br></pre></td></tr></table></figure>

<h2 id="linux-设置PS1"><a href="#linux-设置PS1" class="headerlink" title="linux 设置PS1"></a>linux 设置PS1</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS1=<span class="string">&#x27;\[\e]0;\u@\h: \w\a\]$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u:\[\033[01;34m\]\W\[\033[00m\]\$&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/blog/2022/07/22/record/gitRecord/</url>
    <content><![CDATA[<h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag                             <span class="comment"># 查看tag</span></span><br><span class="line">git tag -a v1.0 -m <span class="string">&#x27;some comments&#x27;</span>  <span class="comment"># 创建</span></span><br><span class="line">git push origin --tags              <span class="comment"># 提交</span></span><br></pre></td></tr></table></figure>
<!-- > git branch -a 查看所有分支
> git branch -d 分支名   （删除本地分支） -->

<h2 id="同步远程分支"><a href="#同步远程分支" class="headerlink" title="同步远程分支"></a>同步远程分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote update origin -p</span><br></pre></td></tr></table></figure>

<h2 id="在本地目录下关联远程repository"><a href="#在本地目录下关联远程repository" class="headerlink" title="在本地目录下关联远程repository"></a>在本地目录下关联远程repository</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:git_username/repository_name.git</span><br></pre></td></tr></table></figure>

<h2 id="取消本地目录下关联的远程库"><a href="#取消本地目录下关联的远程库" class="headerlink" title="取消本地目录下关联的远程库"></a>取消本地目录下关联的远程库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>

<h2 id="git-LF-CRLF默认设置"><a href="#git-LF-CRLF默认设置" class="headerlink" title="git LF CRLF默认设置"></a>git LF CRLF默认设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="git长期存储密码"><a href="#git长期存储密码" class="headerlink" title="git长期存储密码"></a>git长期存储密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>微前端总结</title>
    <url>/blog/2022/07/22/summary/microFrontEnd/</url>
    <content><![CDATA[<!-- ## aaa
![1.png](/images/microFrontEnd/1.png) -->

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>从 <a href="https://micro-frontends.org/">Micro Frontends</a> 官网可以了解到，微前端概念是从微服务概念扩展而来的，摒弃大型单体方式，将前端整体分解为小而简单的块，这些块可以独立开发、测试和部署，同时仍然聚合为一个产品出现在客户面前。可以理解微前端是一种将多个可独立交付的小型前端应用聚合为一个整体的架构风格。</p>
<p><strong>值得留意的几个点：</strong></p>
<ul>
<li>微前端不是一门具体的技术，而是整合了技术、策略和方法，可能会以脚手架、辅助插件和规范约束这种生态圈形式展示出来，是一种宏观上的架构。这种架构目前有多种方案，都有利弊之处，但只要适用当前业务场景的就是好方案。</li>
<li>微前端并没有技术栈的约束。每一套微前端方案的设计，都是基于实际需求出发。如果是多团队统一使用了react技术栈，可能对微前端方案的跨技术栈使用并没有要求；如果是多团队同时使用了react和vue技术栈，可能就对微前端的跨技术栈要求比较高。</li>
</ul>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li><p><strong>同步更新</strong><br>对比了npm包方式抽离，让我们意识到更新流程和效率的重要性。微前端由于是多个子应用的聚合，如果多个业务应用依赖同一个服务应用的功能模块，只需要更新服务应用，其他业务应用就可以立马更新，从而缩短了更新流程和节约了更新成本。</p>
</li>
<li><p><strong>简单、解耦的代码库</strong><br>每个单独的微前端项目的源代码库会远远小于一个单体前端项目的源代码库。这些小的代码库将会更易于开发。更值得一提的是，我们避免了不相关联的组件之间无意造成的不适当的耦合。通过增强应用程序的边界来减少这种意外耦合的情况的出现。</p>
</li>
<li><p><strong>独立部署</strong><br>与微服务一样，微前端的独立可部署性是关键。它减少了部署的范围，从而降低了相关风险。无论您的前端代码在何处托管，每个微前端都应该有自己的连续交付通道，该通道可以构建、测试并将其一直部署到生产环境中。我们应当能够在不考虑其他代码库或者是通道的情况下来部署每个微服务。</p>
</li>
<li><p><strong>多项目合并为一个单页应用</strong><br>很多微前端解决方案可以通过组织HTML或者组件化让多个项目之间合并到一块，成为一个单页应用，让体验更好。</p>
</li>
</ol>
<h2 id="微前端方案种类"><a href="#微前端方案种类" class="headerlink" title="微前端方案种类"></a>微前端方案种类</h2><p><strong>目前国内微前端方案大概分为：</strong></p>
<ul>
<li><strong>基座模式：</strong> 通过搭建基座、配置中心来管理子应用。如基于SIngle Spa的偏通用的qiankun方案，也有基于本身团队业务量身定制的方案。</li>
<li><strong>自组织模式：</strong> 通过约定进行互调，但会遇到处理第三方依赖等问题。</li>
<li><strong>去中心模式：</strong> 脱离基座模式，每个应用之间都可以彼此分享资源。如基于<strong>Webpack 5 Module Federation</strong>实现的EMP微前端方案、或者<strong>nebula微前端</strong>解决方案，可以实现多个应用彼此共享资源分享。</li>
</ul>
<h2 id="现有微前端解决方案"><a href="#现有微前端解决方案" class="headerlink" title="现有微前端解决方案"></a>现有微前端解决方案</h2><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>  众所周知，iframe是html提供的标签，能加载其他web应用的内容，并且它能兼容所有的浏览器，因此，你可以用它来加载任何你想要加载的web应用。iframe最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。<strong>iframe虽然基本能做到微前端所要做的所有事情，但它的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来开发体验、产品体验的问题。</strong><br>  <strong>不足：</strong></p>
<ul>
<li> 不是单页应用，会导致浏览器刷新 iframe url 状态丢失。</li>
<li> 弹框类的功能无法应用到整个大应用中，只能在对应的窗口内展示。</li>
<li> 由于可能应用间不是在相同的域内，主应用的 cookie 要透传到根域名都不同的子应用中才能实现免登录效果。</li>
<li> 每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程，占用大量资源的同时也在极大地消耗资源。 经过以上思考，我个人也有了一些拓展总结：</li>
<li> iframe的特性导致搜索引擎无法获取到其中的内容，进而无法实现应用的seo</li>
</ul>
<h3 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h3><p>  MDN对Web Components的定义是这样的：</p>
<blockquote>
<p>作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的HTML（以及相关的样式和脚本），有时您不得不写代码来呈现自定义UI控件，并且如果您不小心的话，多次使用它们会使您的页面变得一团糟。<br>Web Components旨在解决这些问题 — 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。</p>
</blockquote>
<p>  <strong>它的三项主要技术是指：</strong></p>
<ul>
<li><strong>Custom elements（自定义元素）：</strong>一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。</li>
<li><strong>Shadow DOM（影子DOM）：</strong> 一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。</li>
<li><strong>HTML templates（HTML模板）：</strong> <code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。 通过以上描述，再结合微前端的概念. </li>
</ul>
<p>  <strong>我们来看看Web Components是如何做到微前端：</strong></p>
<ul>
<li><strong>技术栈无关：</strong> Web Components是浏览器原生组件，那即是在任何框架中都可以使用。</li>
<li><strong>独立开发：</strong> 使用Web Components开发的应用无需与其他应用间产生任何关联。</li>
<li><strong>应用间隔离：</strong> Shadow DOM的特性，各个引入的微应用间可以达到相互隔离的效果。 综上所述，Web Components是有能力以组件加载的方式将微应用整合在一起作为微前端的一种手段，但不幸的是，Web Components是浏览器的新特性，所以它的兼容性不是很好，如果有兼容性要求的项目还是无法使用，具体请查看<a href="https://caniuse.com/?search=WebComponents">can i use</a>。<strong>主要是 ShadowDom的兼容性非常不好，一些前端框架在ShadowDom环境下无法正常运行，尤其是react框架（也有解决方案，但是写起来比较麻烦<a href="https://zhuanlan.zhihu.com/p/81427755">参考链接</a>）</strong></li>
</ul>
<h3 id="MicroApp（京东开源）"><a href="#MicroApp（京东开源）" class="headerlink" title="MicroApp（京东开源）"></a><a href="https://zeroing.jd.com/micro-app/docs.html#/zh-cn/start">MicroApp（京东开源）</a></h3><p>  <strong>类WebComponent：</strong> 就是使用CustomElement结合自定义的ShadowDom实现WebComponent基本一致的功能。<br>  由于ShadowDom存在的问题，采用自定义的样式隔离和元素隔离实现ShadowDom类似的功能，然后将微前端应用封装在一个CustomElement中，从而模拟实现了一个类WebComponent组件，它的使用方式和兼容性与WebComponent一致，同时也避开了ShadowDom的问题。并且由于自定义ShadowDom的隔离特性，Micro App不需要像single-spa和qiankun一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改webpack配置。<br>  通过上述方案封装了一个自定义标签micro-app，它的渲染机制和功能与WebComponent类似，开发者可以像使用web组件一样接入微前端。它可以兼容任何框架，在使用方式和数据通信上也更加组件化，这显著降低了基座应用的接入成本，并且由于元素隔离的属性，子应用的改动量也大大降低。<br>  <strong>这是该框架现有的功能对比图（仅供参考）</strong><br>  <img data-src="/images/microFrontEnd/1.png"></p>
<p>  <strong>不足：</strong></p>
<ul>
<li>多个项目之间不能共用相同的依赖</li>
<li>应用级别的引用，不够灵活</li>
<li>框架不够成熟</li>
<li>各浏览器对Custom Elements的支持还不够成熟<br><img data-src="/images/microFrontEnd/8.png"></li>
</ul>
<h3 id="qiankun"><a href="#qiankun" class="headerlink" title="qiankun"></a>qiankun</h3><p>在微前端界，qiankun算得上是最早成型且知名度最广的框架了，它是真正意义上的单页微前端框架，那么qiankun到底有哪些特点呢，在其<a href="https://qiankun.umijs.org/zh/guide">官网</a>中我找到了如下概括：</p>
<ul>
<li>基于single-spa封装，提供了更加开箱即用的 API</li>
<li>技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架</li>
<li>HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单</li>
<li>样式隔离，确保微应用之间样式互相不干扰</li>
<li>JS 沙箱，确保微应用之间 全局变量/事件 不冲突</li>
<li>资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度</li>
<li>umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统 除了最后一点拓展以外，微前端想要达到的效果都已经达到。</li>
</ul>
<p><strong>不足：</strong></p>
<ul>
<li>多个项目之间不能共用相同的依赖</li>
<li>应用级别的引用，不够灵活</li>
</ul>
<h3 id="EMP"><a href="#EMP" class="headerlink" title="EMP"></a>EMP</h3><p><a href="https://github.com/efoxTeam/emp">EMP</a>是由欢聚时代业务中台自主研发的最年轻的单页微前端解决方案<br><strong>功能：</strong></p>
<ul>
<li>基于Webpack5的新特性<strong>Module Federation</strong>实现，达到第三方依赖共享，减少不必要的代码引入的目的。</li>
<li><strong>每个微应用独立部署运行</strong>，并通过cdn的方式引入主程序中，因此只需要部署一次，便可以提供给任何基于Module Federation的应用使用。并且此部分代码是远程引入，无需参与应用的打包。</li>
<li><strong>动态更新微应用</strong>：EMP是通过cdn加载微应用，因此每个微应用中的代码有变动时，无需重新打包发布新的整合应用便能加载到最新的微应用。</li>
<li><strong>去中心化</strong>，每个微应用间都可以引入其他的微应用，无中心应用的概念。</li>
<li><strong>跨技术栈组件式调用</strong>，提供了在主应用框架中可以调用其他框架组件的能力（目前已支持互相调用的框架及使用方式请参阅官方文档）。</li>
<li><strong>按需加载</strong>，开发者可以选择只加载微应用中需要的部分，而不是强制只能将整个应用全部加载（<strong>这是与上面几种微前端解决方案中最大的不同</strong>）。</li>
<li><strong>应用间通信</strong>，每一个应用都可以进行状态共享，就像在使用npm模块进行开发一样便捷。</li>
<li><strong>生成对应技术栈模板</strong>，它能像create-react-app一样，也能像create-vue-app一样，通过指令一键搭建好开发环境，减少开发者的负担。</li>
<li><strong>远程拉取ts声明文件</strong>，emp-cli中内置了拉取远程应用中代码声明文件的能力，让使用ts开发的开发者不再为代码报错而烦恼。</li>
</ul>
<p><strong>不足：</strong></p>
<ul>
<li>是一套全新的脚手架，对现有项目改动较大，老项目迁移都必须用这个框架重构。</li>
<li>没有实现js隔离</li>
<li>使用时会有框架的限制。不过目前已经支持了主流框架。</li>
</ul>
<h3 id="nebula"><a href="#nebula" class="headerlink" title="nebula"></a>nebula</h3><p><a href="https://code.haiziwang.com/b/nebula/cli">nebula</a>是由孩子王自主研发的微前端解决方案。<br><strong>功能：</strong></p>
<ul>
<li>基于Webpack5的新特性<strong>Module Federation</strong>实现，达到第三方依赖共享，减少不必要的代码引入的目的。</li>
<li><strong>每个微应用独立部署运行</strong>，并通过cdn的方式引入主程序中，因此只需要部署一次，便可以提供给任何基于Module Federation的应用使用。并且此部分代码是远程引入，无需参与应用的打包。</li>
<li><strong>动态更新微应用</strong>：EMP是通过cdn加载微应用，因此每个微应用中的代码有变动时，无需重新打包发布新的整合应用便能加载到最新的微应用。</li>
<li><strong>去中心化</strong>，每个微应用间都可以引入其他的微应用，无中心应用的概念。</li>
<li><strong>跨技术栈组件式调用</strong>，提供了在主应用框架中可以调用其他框架组件的能力（目前已支持互相调用的框架及使用方式请参阅官方文档）。</li>
<li><strong>按需加载</strong>，开发者可以选择只加载微应用中需要的部分，而不是强制只能将整个应用全部加载。</li>
<li><strong>远程拉取ts声明文件</strong>，nebula-cli中内置了拉取远程应用中代码声明文件的能力，让使用ts开发的开发者不再为代码报错而烦恼。</li>
</ul>
<p><strong>与EMP的差异：</strong></p>
<ul>
<li>由于公司使用的react脚手架是基于create-react-app的，所以迁移EMP成本较大，但是create-react-app并没有升级到WP5(Webpack5),用不了MF(Module Federation)功能，所以我们将create-react-app 现有版本的基础上升级到WP5(参考create-react-app WP5社区版升级)，后面CRA官方升级WP5之后，可以无缝切换回官方版本</li>
<li>暂时没有实现应用间通信，后面使用场景增加之后，可以添加。</li>
</ul>
<h2 id="nebula使用"><a href="#nebula使用" class="headerlink" title="nebula使用"></a>nebula使用</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ol>
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @nebula/cli -g --registry=https://npmneibu.haiziwang.com/</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化项目</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nebula init</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/microFrontEnd/2.jpg"></p>
<ol start="3">
<li>其他命令</li>
</ol>
<ul>
<li>查看所有命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nebula -h</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/microFrontEnd/3.jpg"></p>
<ul>
<li>创建项目ts文件(其中fileName可以改变d.ts中 declare后面的前缀 默认取package.json中的name， 既package name与MF中的fileName不相等时使用)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nebula tsc -n|--createName, -p|--createPath -f|--fileName  </span><br></pre></td></tr></table></figure>
<ul>
<li>ts类型根据 nebula.config.js 同步</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nebula tsf </span><br></pre></td></tr></table></figure>
<ul>
<li>ts类型远程同步</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nebula tss &lt;remoteUrl&gt; -n|--saveName, -p|--savePath </span><br></pre></td></tr></table></figure>

<p><strong>依赖架构</strong></p>
<p><img data-src="/images/microFrontEnd/4.jpg"></p>
<h3 id="nebula的公共基座"><a href="#nebula的公共基座" class="headerlink" title="nebula的公共基座"></a>nebula的公共基座</h3><p><a href="https://code.haiziwang.com/b/nebula/base">项目base</a> 可以点击查看</p>
<blockquote>
<p>基座需要在package.json配置 build:tsc 命令 用于创建ts声明文件 <strong>MF的语法解释放在后面</strong></p>
</blockquote>
<p><img data-src="/images/microFrontEnd/5.jpg"></p>
<blockquote>
<p>然后在craco.config.js当中将要导出 供其他应用使用的公共 变量、方法或者组件在plugins中配置</p>
</blockquote>
<p><img data-src="/images/microFrontEnd/6.jpg"></p>
<h3 id="nebula的子项目"><a href="#nebula的子项目" class="headerlink" title="nebula的子项目"></a>nebula的子项目</h3><p>真实线上使用项目 1.<a href="https://code.haiziwang.com/b/sales-adviser-b-m">聚客宝雇主端H5</a>  2.<a href="https://code.haiziwang.com/tools-web/business-h5">H5商业化</a></p>
<p>用nebula 初始化过之后需要添加几个配置即可正常使用</p>
<ol>
<li>在package.json中添加一个script</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;prestart&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nebula tsf&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在根目录新建nebula.config.js文件 文件中添加</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">dts</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">saveName</span>: <span class="string">&#x27;nebulatBase.d.ts&#x27;</span>, <span class="comment">// 保存的文件名称</span></span><br><span class="line">      <span class="attr">savePath</span>: <span class="string">&#x27;src/types&#x27;</span>,    <span class="comment">// 保存文件的位置</span></span><br><span class="line">      <span class="attr">remoteUrl</span>: <span class="string">&#x27;https://fedcineibu.haiziwang.com/dts/nebula/nebulaBase.d.ts&#x27;</span>, <span class="comment">// 远程ts地址</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在craco.config.js中的plugins 添加MF配置即可</li>
</ol>
<p><img data-src="/images/microFrontEnd/7.jpg"></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Module Federation 总结</title>
    <url>/blog/2022/07/22/summary/moduleFederation/</url>
    <content><![CDATA[<h2 id="什么是Module-Federation（简称MF）"><a href="#什么是Module-Federation（简称MF）" class="headerlink" title="什么是Module Federation（简称MF）"></a>什么是Module Federation（简称MF）</h2><p>MF是webpack5的新特性，关于 module federation，webpack5 官方文档给出了相关说明，原文如下：</p>
<blockquote>
<p>Multiple separate builds should form a single application. These separate builds should not have dependencies between each other, so they can be developed and deployed individually. This is often known as Micro-Frontends, but is not limited to that.</p>
</blockquote>
<p>解释如下：一个应用可以由多个独立的构建组成。这些独立的构建之间没有依赖关系，他们可以独立开发、部署。<br>上述解释，其实就是微前端的概念。<br>使用 module federation，我们可以在一个 javascript 应用中动态加载并运行另一个 javascript 应用的代码，并实现应用之间的依赖共享。</p>
<h2 id="MF-配置项"><a href="#MF-配置项" class="headerlink" title="MF 配置项"></a>MF 配置项</h2><p><a href="https://github.com/module-federation/module-federation-examples">社区MF配置案例</a><br>一个完整的 module federation 配置项，包含内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ModuleFederationPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">library</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">remotes</span>: &#123;</span><br><span class="line">        <span class="attr">app2</span>: <span class="string">&#x27;app2@xxxx&#x27;</span>,</span><br><span class="line">        <span class="attr">app3</span>: <span class="string">&#x27;app3@xxxx&#x27;</span>,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">exposes</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;./Button&#x27;</span>: <span class="string">&#x27;./src/Button&#x27;</span>,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">shared</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;react&#x27;</span>: &#123;</span><br><span class="line">            <span class="attr">import</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">            <span class="attr">singleton</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">requiredVersion</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">            <span class="attr">strictVersion</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">            <span class="attr">shareScope</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">            <span class="attr">packageName</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">            <span class="attr">sharedKey</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">            <span class="attr">eager</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">shareScope</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>name</strong><br>当前应用的别名。</p>
</li>
<li><p><strong>filename</strong><br>入口文件名， remote 应用供 host 应用消费时，remote 应用提供的远程文件的文件名。</p>
</li>
<li><p><strong>exposes</strong><br>remote 应用被 host 应用消费时，有哪些输出内容可以被 host 应用使用。<br>exposes 是一个对象， key 为输出内容在 host 应用中的相对路径，value 为输出内容的在当前应用的相对路径(也可以是绝对路径, 大部分情况应该写相对路径)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ModuleFederationPlugin</span>(&#123;</span><br><span class="line">  ...,</span><br><span class="line">  <span class="attr">exposes</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;./Button&#x27;</span>: <span class="string">&#x27;../src/component/Button&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>!<strong>注意：</strong> 如果我们在 host 应用中是 import(‘app2/Button’), 那么 exposes 中的 key 必须为 ‘./Button’; 如果是 import(‘app2/shared/Button’)， 那么 exposes 中的 key 必须为 ‘./shared/Button’</p>
</li>
<li><p><strong>library</strong><br>library 定义了 remote 应用如何将输出内容暴露给 host 应用。<br>配置项的值是一个对象，如 { type: ‘xxx’, name: ‘xxx’} <strong>type 默认值是var, name默认取的外层name值</strong><br>其中，name，暴露给外部应用的变量名； type，暴露变量的方式。<br>type 的值，和 output.libraryTarget 的值类似，可取的值有:</p>
<ul>
<li><strong>var</strong> : remote 的输出内容分配给一个通过 var 定义的变量；<img data-src='/images/moduleFederation/1.jpg' style='width: 800px'/> </li>
<li><strong>window</strong> : remote 的输出内容作为 window 对象的一个属性，属性名为 name 对应的值；<img data-src='/images/moduleFederation/2.jpg' style='width: 800px'/></li>
<li><strong>assign</strong>: remote 的输出内容分配给一个不通过 var 定义的变量；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app2 = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">__webpack_require__</span>(...);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><strong>this</strong>: remote 的输出内容作为当前上下文 this 的一个属性，属性名为 name 对应的值；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>[<span class="string">&quot;app2&quot;</span>] = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">__webpack_require__</span>(...);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li>
<li><strong>self</strong>: remote 的输出内容作为 self 对象的一个属性，属性名为 name 对应的值；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self[<span class="string">&quot;app2&quot;</span>] = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">__webpack_require__</span>(...);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><strong>commonjs</strong>: remote 的输出内容作为 exports 的一个 属性，属性名为 name 对应的值；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;app2&quot;</span>] = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">__webpack_require__</span>(...);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><strong>commonjs2</strong>: remote 的输出内容作为 module.exports 的一个 属性，属性名为 name 对应的值；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>[<span class="string">&quot;app2&quot;</span>] = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">__webpack_require__</span>(...);</span><br><span class="line">&#125;)();   </span><br></pre></td></tr></table></figure></li>
<li><strong>amd</strong>: remoteEntry.js 符合 AMD 规范；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="string">&#x27;app2&#x27;</span>, [], <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> (<span class="function">() =&gt;</span> &#123;...&#125;)()&#125;);</span><br></pre></td></tr></table></figure></li>
<li><strong>umd</strong>: remoteEntry.js 符合 UMD 规范；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">root, factory</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">      <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>)</span><br><span class="line">      <span class="title function_">define</span>([], factory);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">      <span class="built_in">exports</span>[<span class="string">&quot;app2&quot;</span>] = <span class="title function_">factory</span>();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      root[<span class="string">&quot;app2&quot;</span>] = <span class="title function_">factory</span>();</span><br><span class="line">&#125;(<span class="variable language_">window</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function">() =&gt;</span> &#123;...&#125;)()&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><strong>jsonp</strong>: 将 remote 的输出内容包裹到一个 jsonp 包装容器中;<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">app2</span>((<span class="function">() =&gt;</span>&#123;...&#125;)())</span><br></pre></td></tr></table></figure></li>
<li><strong>system</strong>: remoteEntry.js 符合 Systemjs 规范；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">System</span>.<span class="title function_">register</span>(<span class="string">&quot;app2&quot;</span>, [], <span class="keyword">function</span>(<span class="params">__WEBPACK_DYNAMIC_EXPORT__, __system_context__</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">execute</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">__WEBPACK_DYNAMIC_EXPORT__</span>(...)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>remotes</strong><br>被当前 host 应用消费的 remote 应用。<br>remotes 是一个对象，key 值是一个要消费的应用的别名。如果我们在要 host 应用中使用 remote 应用的 button 组件时，我们的代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">RemoteButton</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;app2/button));</span></span><br></pre></td></tr></table></figure>
<p>其中， import url 中的 app2 对应 remotes 配置项中的 key 值。<br>value 为 remote 应用的对外输出及url，**格式必须严格遵循: ‘name@url’**。其中， name 对应 remote 应用中 library 中的 name 配置项， url 对应 remote 应用中 remoteEnter 文件的链接。</p>
</li>
<li><p><strong>shared</strong><br>shared 配置项指示 remote 应用的输出内容和 host 应用可以共用哪些依赖。 <strong>shared 要想生效，则 host 应用和 remote 应用的 shared 配置的依赖要一致</strong>。</p>
<ul>
<li><strong>import</strong><br>共享依赖的实际的 package name。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  <span class="attr">shared</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;react-shared&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">import</span>: <span class="string">&#x27;react&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果未指定，默认为用户自定义的共享依赖名，即 react-shared。如果是这样的话，webpack 打包是会抛出异常的，因为实际上并没有 react-shared 这个包。</li>
<li><strong>singleton</strong><br>是否开启单例模式。默认值为 false，即不开单例模式，如果值为 true，开启单例模式；值为 false，不开启单例模式。<br>如何启用单例模式，那么 remote 应用组件和 host 应用共享的依赖只加载一次，且与版本无关。<br>如果版本不一致，会给出警告。<br>加载的依赖的版本为 remote 应用和 host 应用中，版本比较高的。<br>不开启单例模式下，如果 remote 应用和 host 应用共享依赖的版本不一致，remote 应用和 host 应用需要分别各自加载依赖。</li>
<li><strong>requiredVersion</strong><br>指定共享依赖的版本，默认值为当前应用的依赖版本。<br>如果 requiredVersion 与实际应用的依赖的版本不一致，会给出警告。</li>
<li><strong>strictVersion</strong><br>是否需要严格的版本控制，默认值为 false。<br>单例模式下，如果 strictVersion 与实际应用的依赖的版本不一致，会抛出异常。</li>
<li><strong>shareKey</strong><br>共享依赖的别名, 默认值值 shared 配置项的 key 值。</li>
<li><strong>shareScope</strong><br>当前共享依赖的作用域名称，默认为 default<br>打包之后会作为 <code>__webpack_require__.S</code> 的key, <code>__webpack_require__.S[&quot;default&quot;]</code> 中的 default 即为 shareScope 指定的 default</li>
<li><strong>eager</strong><br>共享依赖在打包过程中是否被分离为 async chunk，默认值为 false。<br>eager 为 false， 共享依赖被单独分离为 async chunk； eager 为 true， 共享依赖会打包到 main、remoteEntry，不会被分离。<br>如果设置为 true， 共享依赖其实是没有意义的，在某些场景下如果依赖单独分离成async chunk时报错，可以改为true。</li>
</ul>
</li>
<li><p><strong>shareScope</strong><br>所用共享依赖的作用域名称，默认为 default。<br>如果 shareScope 和 share[“xxx”].shareScope 同时存在，share[“xxx”].shareScope 的优先级更高。</p>
</li>
</ul>
<h2 id="shared解析及常用配置"><a href="#shared解析及常用配置" class="headerlink" title="shared解析及常用配置"></a>shared解析及常用配置</h2><p>module federation 在初始化 shareScope 时，会比较 host 应用和 remote 应用之间共享依赖的版本，将 shareScope 中共享依赖的版本更新为较高版本。<br>在加载共享依赖时，如果发现实际需要的版本和 shareScope 中共享依赖的版本不一致时，会根据 share 配置项的不同做相应处理：</p>
<blockquote>
<p>如果配置 singleton 为 ture，实际使用 shareScope 中的共享依赖，控制台会打印版本不一致警告；<br>如果配置 singleton 为 ture，且 strictVersion 为 ture，即需要保证版本必须一致，会抛出异常；<br>如果配置 singleton 为 false，那么应用不会使用 shareScope 中的共享依赖，而是加载应用自己的依赖；<br>综上，如果 host 应用和 remote 应用共享依赖的版本可以兼容，可将 singleton 配置为 ture；如果共享依赖版本不兼容，需要将 singleton 配置为 false。</p>
</blockquote>
<p>shared参数常用配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deps = <span class="built_in">require</span>(<span class="string">&quot;./package.json&quot;</span>).<span class="property">dependencies</span>;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ModuleFederationPlugin</span>(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">shared</span>: &#123;</span><br><span class="line">    ...deps, <span class="comment">// 所有dependencies 依赖共享</span></span><br><span class="line">    <span class="attr">moment</span>: deps.<span class="property">moment</span>, <span class="comment">// 单独共享，如果版本不一致则各自用各自的依赖</span></span><br><span class="line">    <span class="attr">react</span>: &#123;  <span class="comment">// react开启单例模式 strictVersion默认false 版本不一致会警告，不会报错，共享依赖的版本不一致时取较高版本</span></span><br><span class="line">      <span class="attr">singleton</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;react-dom&quot;</span>: &#123; <span class="comment">// 和上面react 类似，requiredVersion 默认值为当前应用的依赖版本可以不写</span></span><br><span class="line">      <span class="attr">requiredVersion</span>: deps[<span class="string">&quot;react-dom&quot;</span>],</span><br><span class="line">      <span class="attr">singleton</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">react</span>: &#123; <span class="comment">// 详细配置 看上面各配置项解析---不常用</span></span><br><span class="line">      <span class="attr">import</span>: <span class="string">&quot;react&quot;</span>, <span class="comment">// the &quot;react&quot; package will be used a provided and fallback module</span></span><br><span class="line">      <span class="attr">requiredVersion</span>: deps.<span class="property">react</span>,</span><br><span class="line">      <span class="attr">shareKey</span>: <span class="string">&quot;react&quot;</span>, <span class="comment">// under this name the shared module will be placed in the share scope</span></span><br><span class="line">      <span class="attr">shareScope</span>: <span class="string">&quot;default&quot;</span>, <span class="comment">// share scope with this name will be used</span></span><br><span class="line">      <span class="attr">singleton</span>: <span class="literal">true</span>, <span class="comment">// only a single version of the shared module is allowed</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="MF工作原理浅析"><a href="#MF工作原理浅析" class="headerlink" title="MF工作原理浅析"></a>MF工作原理浅析</h2><h3 id="正常情况下webpack构建应用"><a href="#正常情况下webpack构建应用" class="headerlink" title="正常情况下webpack构建应用"></a>正常情况下webpack构建应用</h3><p>webpack 在构建过程中，会以 entry 配置项对应的入口文件为起点，收集整个应用中需要的所有模块，建立模块之间的依赖关系，生成一个模块依赖图。然后再将这个模块依赖图，切分为多个 chunk，输出到 output 配置项指定的位置。<br>通常情况下，一个完整的 webpack 构建，它的结构一般如下：<br><img data-src='/images/moduleFederation/3.jpg' style='width: 800px'/></p>
<p>最后的构建内容包括：main-chunk 和 async chunk。<br><strong>main-chunk</strong> 为入口文件(通常为 index.js) 所在的 chunk，内部包含 runtime 模块、index 入口模块、第三方依赖模块(如 react、react-dom、antd 等)和内部组件模块(如 com-1、com-2 等)；<br><strong>async-chunk</strong> 为异步 chunk，内部包含需要异步加载(懒加载)的模块。</p>
<p>现在以社区MF案例 <a href="https://github.com/module-federation/module-federation-examples/tree/master/advanced-api/automatic-vendor-sharing">automatic-vendor-sharing</a>为例</p>
<div style='widht: 800px;display: flex; align-items: center;justify-content: center;'>
    <img data-src="/images/moduleFederation/5.jpg" style='min-width: 300px'/>
    <div style='display: flex; flex-wrap: wrap;'>
      <div style='display: flex'>
        <img data-src="/images/moduleFederation/6.jpg" style='flex: 1'/>
        <img data-src="/images/moduleFederation/7.jpg" style='flex: 1'/>
      </div>
      <div style='display: flex'>
        <img data-src="/images/moduleFederation/8.jpg" style='flex: 1'/>
        <img data-src="/images/moduleFederation/9.jpg" style='flex: 1'/>
      </div>
    </div>
</div>

<p>如果未使用 module federation 功能，那他们的 webpack 构建如下：<br><img data-src='/images/moduleFederation/4.jpg' style='width: 800px'/></p>
<blockquote>
<p>看上图，我们会发现 在index.js 中，是通过 import(“./bootstrap”) 的方式导入 bootstrap.js 的，导致会生成一个包含 bootstrap、App、Button、React、React-dom 的 async chunk。webpack 在打包过程中，如果发现 async-chunk 中有第三方依赖(即 react、react-dom)，则会把第三方依赖从 async-chunk 中分离，构建一个新的 vendors-chunk。</p>
</blockquote>
<p><strong>截取部分代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main-chunk</span></span><br><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用于缓存模块的执行方法。key 值对应模块的 id， value对应模块的执行方法。</span></span><br><span class="line">  <span class="comment">// webpack 在打包时，会把每一个模块处理为一个执行方法。当运行这个执行方法时，会执行模块对应的相关代码，并返回模块的输出</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 用于缓存模块的输出。key值对应模块的 id，value 对应模块的输出。</span></span><br><span class="line">  <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用于获取模块的输出。源代码中的 &quot;import xx from &#x27;xxx&#x27;&quot;,最终会被转化为 __webpack_require__(...) 的形式。</span></span><br><span class="line">  <span class="comment">// __webpack_require__方法在获取模块输出时，会先根据模块 id 在__webpack_module_cache 中查找对应的输出。如果没有找到，就去 __webpack_modules__ 中获取模块的执行方法，然后运行模块的执行方法，获取模块的输出并缓存到 __webpack_module_cache 中。</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">__webpack_require__</span>(<span class="params">moduleId</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;</span><br><span class="line">          <span class="keyword">return</span> __webpack_module_cache__[moduleId].<span class="property">exports</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> <span class="variable language_">module</span> = __webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">          <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      __webpack_module__[moduleId](<span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>, __webpack_require);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重要：__webpack_require__.l 是一个方法，用于加载 async-chunk。__webpack_require__.l 会根据 async-chunk 对应的 url，通过动态添加 script 的方式，获取 async-chunk 对应的 js 文件，然后执行。</span></span><br><span class="line">  __webpack_require__.<span class="property">l</span> = <span class="function">(<span class="params">url, done, key, chunkId</span>) =&gt;</span> &#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  __webpack_require__.<span class="property">f</span>.<span class="property">j</span> = <span class="function">(<span class="params">chunkId, promises</span>) =&gt;</span> &#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用于缓存 chunk。key 值对应 chunk 的 id，value 为 0。</span></span><br><span class="line">  <span class="keyword">var</span> installedChunks = &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//webpackJsonpCallback 是一个挂载到全局变量(window、global、self) 上的全局方法，用于安装 chunk。这个方法执行时，会把 chunk 内部包含的模块及模块的执行方法收集到 __webpack_modules__ 中。</span></span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">webpackJsonpCallback</span> = (<span class="params">parentChunkLoadingFunction, data</span>) =&gt; &#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> chunkLoadingGlobal = self[<span class="string">&quot;webpackChunk_automatic_vendor_sharing_app1&quot;</span>] = self[<span class="string">&quot;webpackChunk_automatic_vendor_sharing_app1&quot;</span>] || [];</span><br><span class="line">  chunkLoadingGlobal.<span class="title function_">forEach</span>(webpackJsonpCallback.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">0</span>));</span><br><span class="line">  chunkLoadingGlobal.<span class="property">push</span> = webpackJsonpCallback.<span class="title function_">bind</span>(<span class="literal">null</span>, chunkLoadingGlobal.<span class="property">push</span>.<span class="title function_">bind</span>(chunkLoadingGlobal));</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">all</span>(<span class="comment">/* import() */</span>[__webpack_require__.<span class="title function_">e</span>(<span class="number">935</span>), __webpack_require__.<span class="title function_">e</span>(<span class="number">902</span>)]).<span class="title function_">then</span>(__webpack_require__.<span class="title function_">bind</span>(__webpack_require__, <span class="number">902</span>));</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vendors-chunk</span></span><br><span class="line">(self[<span class="string">&quot;webpackChunk_automatic_vendor_sharing_app1&quot;</span>] = self[<span class="string">&quot;webpackChunk_automatic_vendor_sharing_app1&quot;</span>] || []).<span class="title function_">push</span>([[<span class="number">935</span>],&#123;</span><br><span class="line">  <span class="string">&quot;./node_modules/react-dom/cjs/react-dom.development.js&quot;</span>: <span class="function">(<span class="params">__unused_webpack_module, <span class="built_in">exports</span>, __webpack_require__</span>) =&gt;</span> &#123; ... &#125;,</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async-chunk</span></span><br><span class="line">(self[<span class="string">&quot;webpackChunk_automatic_vendor_sharing_app1&quot;</span>] = self[<span class="string">&quot;webpackChunk_automatic_vendor_sharing_app1&quot;</span>] || []).<span class="title function_">push</span>([[<span class="number">902</span>],&#123;</span><br><span class="line">    <span class="string">&quot;./src/App.js&quot;</span>: <span class="function">(<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123; ... &#125;,</span><br><span class="line">    <span class="string">&quot;./src/Button.js&quot;</span>: <span class="function">(<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123; ... &#125;,</span><br><span class="line">    <span class="string">&quot;./src/bootstrap.js&quot;</span>: <span class="function">(<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123; ... &#125;,</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
<p><strong>webpack 构建的大致工作过程：</strong></p>
<ol>
<li>打开应用，加载 main-chunk 对应的 js 文件；</li>
<li>执行 main-chunk.js， 定义 <strong>webpack_modules__、__webpack_module_cache__、__webpack_require__、installedChunks、webpackJsonpCallback、__webpack_require</strong>.l 等；</li>
<li>执行入口模块 index 对应的代码；</li>
<li>如果遇到依赖模块，通过 <strong>webpack_require</strong> 方法获取依赖模块的输出(先从 __webpack_module_cache 中获取，如果没有，运行 <strong>webpack_modules</strong> 中模块对应的执行方法 );</li>
<li>如果遇到懒加载模块，通过 <strong>webpack_modules</strong>.l 方法获取对应的 async-chunk 并执行，然后获取相应的输出；</li>
</ol>
<h3 id="使用-module-federation-的-webpack-构建"><a href="#使用-module-federation-的-webpack-构建" class="headerlink" title="使用 module federation 的 webpack 构建"></a>使用 module federation 的 webpack 构建</h3><p>app1、app2 使用 module federation 功能以后，对应的 webpack 构建如下：<br><img data-src='/images/moduleFederation/10.jpg' style='width: 800px'/></p>
<blockquote>
<p>在新的打包文件中，我们发现新增了 remoteEntry-chunk、包含 button 模块的 expose-chunk 以及包含 react 模块的 shared-chunk1 和 包含 react-dom 模块的 shared-chunk2。<br>remoteEntry-chunk 内部主要包含 runtime 模块，expose-chunk 中包含可被 host 应用使用的 button 组件</p>
</blockquote>
<p>出现上述情况，主要和 ModuleFederationPlugin 的 exposes、shared 配置项有关。</p>
<blockquote>
<p>首先是 exposes 配置项。exposes 配置项定义了 remote 应用的哪些组件可以被 host 应用使用。webpack 打包时，会根据 exposes 配置项，生成一个 remoteEntry-chunk 和多个 expose-chunk。应用启动以后，host 应用就可以根据 remotes 配置项指定的 url 去加载 remote 应用的 remoteEntry-chunk 和 expose-chunk。<br>其次是 shared 配置项。shared 配置项定义了 host 应用和 remote 应用的 expose-chunk 之间可共享的依赖。shared 指定了共享的依赖为 react、react-dom，因此 react 模块和 react-dom 模块会被分离为新的 shared-chunk。</p>
</blockquote>
<p>app1和app2的MF配置如下</p>
<div style='widht: 800px;display: flex; align-items: center;justify-content: center;'>
  <img data-src="/images/moduleFederation/11.jpg" style='flex: 1'/>
  <img data-src="/images/moduleFederation/12.jpg" style='flex: 1'/>
</div>

<p>通过前面打包之后的图片可以猜到module federation 实现应用间组件互用的原理。<br>就是 remote 应用生成一个 remoteEntry-chunk 和多个 expose-chunk。 host 应用启动后，通过 remotes 配置项指定的 url，去动态加载 remote 应用的 remoteEntry-chunk 和 expose-chunk，然后执行并渲染 remote 应用的组件。</p>
<p>在 一个常见的 webpack 构建如何工作 的构建结果中，我们可以发现多个 webpack 构建之间其实是相互隔离、无法互相访问的。那么 module federation 是如何打破这种隔离的呢？<br>答案是 <strong>sharedScope</strong> - 共享作用域。应用启动以后， host 应用和 remote 应用的 remote-chunk 之间会建立一个可共享的 sharedScope，内部包含可共享的依赖。</p>
<p>使用 module federation 功能以后，webpack 会在 app1 应用的 main-chunk 的 runtime 模块中添加一段逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">// 运行执行方法时，会动态加载 app2 的 remoteEntry.js。  </span></span><br><span class="line">    <span class="string">&quot;webpack/container/reference/app2&quot;</span>: <span class="function">(<span class="params"><span class="variable language_">module</span>, __webpack_exports, __webpack_require__</span>) =&gt;</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	     ...</span><br><span class="line">	     __webpack_require__.<span class="title function_">l</span>(<span class="string">&quot;http://localhost:3002/remoteEntry.js&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;...&#125;, <span class="string">&quot;app2&quot;</span>);</span><br><span class="line">       &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> app2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// S 是一个普通对象，用于存储 app1 中 shared 配置项指定的共享内容。</span></span><br><span class="line">    __webpack_require__.<span class="property">S</span> = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法用于初始化 app1 的 __webpack_require__.S 对象。</span></span><br><span class="line">    __webpack_require__.<span class="property">I</span> = <span class="function">(<span class="params">name, initScope</span>) =&gt;</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="keyword">var</span> scope = __webpack_require__.<span class="property">S</span>[name];</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//会将 shared 配置项指定的共享依赖及获取方法添加到 __webpack_require__.S 中；</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title function_">register</span> = (<span class="params">name, version, factory</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> versions = scope[name] = scope[name] || &#123;&#125;;</span><br><span class="line">            <span class="keyword">var</span> activeVersion = versions[version];</span><br><span class="line">            <span class="keyword">if</span>(!activeVersion || !activeVersion.<span class="property">loaded</span> &amp;&amp; uniqueName &gt; activeVersion.<span class="property">from</span>) versions[version] = &#123; <span class="attr">get</span>: factory, <span class="attr">from</span>: uniqueName &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//会加载 app2 提供的 remoteEntry.js，然后使用 app1 应用的 __webpack_require__.S 来初始化 app2 应用的 __webpack_require__.S 对象。</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title function_">initExternal</span> = (<span class="params">id</span>) =&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">var</span> <span class="variable language_">module</span> = <span class="title function_">__webpack_require__</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="variable language_">module</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> <span class="title function_">initFn</span> = (<span class="params"><span class="variable language_">module</span></span>) =&gt; <span class="variable language_">module</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">init</span> &amp;&amp; <span class="variable language_">module</span>.<span class="title function_">init</span>(__webpack_require__.<span class="property">S</span>[name], initScope);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">module</span>.<span class="property">then</span>) <span class="keyword">return</span> promises.<span class="title function_">push</span>(<span class="variable language_">module</span>.<span class="title function_">then</span>(initFn, handleError));</span><br><span class="line">            <span class="keyword">var</span> initResult = <span class="title function_">initFn</span>(<span class="variable language_">module</span>);</span><br><span class="line">            <span class="keyword">if</span>(initResult &amp;&amp; initResult.<span class="property">then</span>) <span class="keyword">return</span> promises.<span class="title function_">push</span>(initResult.<span class="title function_">catch</span>(handleError));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span>(name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;default&quot;</span>: &#123;</span><br><span class="line">                <span class="title function_">register</span>(<span class="string">&quot;react-dom&quot;</span>, <span class="string">&quot;17.0.1&quot;</span>, <span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([__webpack_require__.<span class="title function_">e</span>(<span class="string">&quot;vendors-node_modules_react-dom_index_js&quot;</span>), __webpack_require__.<span class="title function_">e</span>(<span class="string">&quot;webpack_sharing_consume_default_react_react-_2997&quot;</span>)]).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="function">() =&gt;</span> <span class="title function_">__webpack_require__</span>(<span class="comment">/*! ./node_modules/react-dom/index.js */</span> <span class="string">&quot;./node_modules/react-dom/index.js&quot;</span>)));</span><br><span class="line">                <span class="title function_">register</span>(<span class="string">&quot;react&quot;</span>, <span class="string">&quot;17.0.1&quot;</span>, <span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([__webpack_require__.<span class="title function_">e</span>(<span class="string">&quot;vendors-node_modules_react_index_js&quot;</span>), __webpack_require__.<span class="title function_">e</span>(<span class="string">&quot;node_modules_object-assign_index_js&quot;</span>)]).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="function">() =&gt;</span> <span class="title function_">__webpack_require__</span>(<span class="comment">/*! ./node_modules/react/index.js */</span> <span class="string">&quot;./node_modules/react/index.js&quot;</span>)));</span><br><span class="line">                <span class="title function_">initExternal</span>(<span class="string">&quot;webpack/container/reference/app2&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p> app2 应用的 remote-chunk 的代码片段如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> app2 = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> __webpack_modules = (&#123;</span><br><span class="line">        <span class="string">&quot;webpack/container/entry/app2&quot;</span>: <span class="function">(<span class="params">__unused_webpack_module, <span class="built_in">exports</span>, __webpack_require__</span>) =&gt;</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">var</span> <span class="title function_">get</span> = (<span class="params"><span class="variable language_">module</span>, getScope</span>) =&gt; &#123;...&#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这个方法会使用 app1 的 __webpack_require__.S 来初始化 app2 的 __webpack_require__.S。</span></span><br><span class="line">          <span class="comment">// 在初始化的时候，会对比 app1 、app2 中 react、react-dom 的版本，将 shareScope 中的共享依赖更新为两个应用里面较新的版本。</span></span><br><span class="line">          <span class="comment">// 即如果 app1 中 react 的版本高于 app2， 那么 __webpeck_require__.S[default].react的 from 和 init 属性对应 app1，实际使用时 react 是从 app1 中获取；反之__webpeck_require__.S[default].react的 from 和 init 属性对应 app2，实际使用时 react 是从 app2 中获取.</span></span><br><span class="line">          <span class="keyword">var</span> <span class="title function_">init</span> = (<span class="params">shared, initScope</span>) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (!__webpack_require__.<span class="property">S</span>) <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">var</span> oldScope = __webpack_require__.<span class="property">S</span>[<span class="string">&quot;default&quot;</span>];</span><br><span class="line">              <span class="keyword">var</span> name = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">              ...</span><br><span class="line">              __webpack_require__.<span class="property">S</span>[name] = shareScope;</span><br><span class="line">            <span class="keyword">return</span> __webpack_require__.<span class="title function_">I</span>(name, initScope);</span><br><span class="line">          &#125;</span><br><span class="line">          __webpack_require__.<span class="title function_">d</span>(<span class="built_in">exports</span>, &#123;</span><br><span class="line">              <span class="attr">get</span>: <span class="function">() =&gt;</span> get;</span><br><span class="line">              <span class="attr">init</span>: <span class="function">() =&gt;</span> init</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">// 中间部分和 app1 的 main-chunk 的 runtime 基本相同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">__webpack_require</span>(<span class="string">&quot;webpack/container/entry/app2&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>以上依赖共享的实现逻辑，简要流程：</p>
<ol>
<li>打开应用 app1， 加载 main-chunk 对应的 js 文件；</li>
<li>执行 main-chunk.js， 定义 <strong>webpack_modules__、__webpack_module_cache__、__webpack_require__、installedChunks、webpackJsonpCallback、__webpack_require</strong>.l、<strong>webpack_require</strong>.S、<strong>webpack_require</strong>.I 等；</li>
<li>执行入口模块 index.js 对应的代码。执行时，会触发 <strong>webpack_require</strong>.I 的执行；</li>
<li><strong>webpack_require</strong>.I 方法开始执行，首先通过 register 方法初始化 <strong>webpack_require</strong>.S 对象，然后通过 initExternal 方法去获取 app2 的 remoteEntry.js。获取 app2 的 remoteEntry.js 时，会返回一个 promise 对象，当 app2 的 remoteEntry.js 加载并执行完毕时， promise 的状态才会变为 resolved；</li>
<li>动态加载 app2 应用 的 remoteEntry.js 并执行，返回一个包含 get、init 的全局变量 app2；</li>
<li>步骤 4 中的 promise 对象的状态变为 resolved，注册的 callback 触发，开始执行 app2.init；</li>
<li>app2.init 方法执行，使用 app1 应用的 <strong>webpack_require</strong>.S 初始化 app1 应用的 <strong>webpack_require</strong>.S。</li>
</ol>
<p>应用启动以后， app1 的结构如下：<br><img data-src='/images/moduleFederation/13.jpg' style='width: 800px'/></p>
<h3 id="为什么-index-js-中需要以-import-的方式引入-bootstrap-js-？"><a href="#为什么-index-js-中需要以-import-的方式引入-bootstrap-js-？" class="headerlink" title="为什么 index.js 中需要以 import() 的方式引入 bootstrap.js ？"></a>为什么 index.js 中需要以 import() 的方式引入 bootstrap.js ？</h3><p>如果不使用```import()``这种写法会报错</p>
<ol>
<li>使用import()这种写法，入口文件会回打包进异步chunk</li>
<li>在异步chunk中，会去加载所有需要的依赖，也就是依赖前置</li>
<li>在加载的过程中发现依赖的远程remotes，会加载该remotes的js</li>
<li>remotes的js又会有各种依赖，根据MF的shared配置，将共享依赖放到之前提到的 shareScope 即共享作用域</li>
<li>所有依赖以及chunk都加载完成之后，才会去执行bootstrap.js里面的module 进行正常渲染了<img data-src='/images/moduleFederation/14.jpg' style='width: 500px'/></li>
</ol>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>微前端</tag>
        <tag>Module Federation</tag>
      </tags>
  </entry>
</search>
